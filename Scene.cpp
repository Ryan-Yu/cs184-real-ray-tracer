#include <vector>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cmath>
#include <string>
#include <limits>
#include <cfloat>

#include "Vector3.h"
#include "Vector4.h"
#include "Sample.h"
#include "Point.h"
#include "Normal.h"
#include "Matrix4.h"
#include "Transformation.h"
#include "Ray.h"
#include "DifferentialGeometry.h"
#include "Color.h"
#include "BRDFCoefficients.h"
#include "Material.h"
#include "Shape.h"
#include "Primitive.h"
#include "Intersection.h"
#include "AggregatePrimitive.h"
#include "Film.h"
#include "Camera.h"
#include "Light.h"

#include "lodepng.h"

#ifdef _WIN32
#include <windows.h>
#else
#include <sys/time.h>
#endif

#include <time.h>
#include <math.h>
#include <stdio.h>
#include <bitset>
#include <algorithm>

using namespace std;


//****************************************************
// Forward Declarations
//****************************************************
static void printRay(Ray ray);
static void printSample(Sample sample);
static void printColor(Color color);
void printCommandLineOptionVariables();
void printSamples();
Color applyShadingModel(DifferentialGeometry differentialGeometry, BRDFCoefficients brdf, Ray lightRay, Color lightColor);
class RayTracer;


//****************************************************
// Global Variables
//****************************************************
bool debug;
std::vector<Sample> samples;
Film film;
Camera camera;
int recursionDepth;
AggregatePrimitive aggregatePrimitive;
std::vector<PointLight> point_lights;
std::vector<DirectionalLight> directional_lights;

class RayTracer {
	public:
		void trace(Ray& ray, int depth, Color* color) {
			if (depth > recursionDepth) {
				color->r = 0;
				color->g = 0;
				color->b = 0;
				return;
			}

//			// For testing only: shade coordinate red if ray intersects it, else shade black
//			if (!aggregatePrimitive.intersectP(ray)) {
//				color->r = 0;
//				color->g = 0;
//				color->b = 0;
//				return;
//			} else {
//				//For testing purposes, simply shade red if the ray intersects the point
//				color->r = 255;
//				color->g = 0;
//				color->b = 0;
//			}

			// TODO: this may be wrong
			float tHit;
			Intersection intersection;

			// This method will populate tHit and intersection if there is an intersection with this ray and any primitive.
			if (!aggregatePrimitive.intersect(ray, &tHit, &intersection) ) {
				// If no intersection, then make the color black and return
				color->r = 0;
				color->g = 0;
				color->b = 0;
				return;
			}

			BRDFCoefficients brdf;
			// This method will populate the brdf variable with the brdf values of the intersection primitive.
			brdf = intersection.primitive->getBRDF(intersection.differentialGeometry, &brdf);

			// Initialize a new Color with R = G = B = 0.0
			// This color will be appended to with our shading model
			Color colorOfPixel;
			Ray lightRay;
			Color lightColor;

			float intersectionXCoor = intersection.differentialGeometry.position.x;
			float intersectionYCoor = intersection.differentialGeometry.position.y;
			float intersectionZCoor = intersection.differentialGeometry.position.z;

			// We want to add the ambient term even if our shape is blocked by a light
			color->r += brdf.ka.r;
			color->g += brdf.ka.g;
			color->b += brdf.ka.b;

			// There is an intersection, so we have to loop through all the light source
			// and consider their contributions to the intersection pixel
			for (std::vector<DirectionalLight>::size_type i = 0; i < directional_lights.size(); i++) {

				// Generate light ray from the intersection point to the light position
				// For directional lights, this is generated by subtracting the position of the intersection point
				// from the position of the light (IN WORLD COORDINATES)
				directional_lights[i].generateLightRay(intersection.differentialGeometry, &lightRay, &lightColor);

				Ray reversedLightRay = Ray(lightRay.position, lightRay.direction.scaleVector(-1.0), lightRay.t_min, lightRay.t_max);

				// ***** Regular shading + shadows *****
				// If the light ray is not blocked, we apply our shading model
				if (!aggregatePrimitive.intersectP(reversedLightRay)) {
					Color colorToAdd = applyShadingModel(
							intersection.differentialGeometry,
							brdf,
							lightRay,
							Color(directional_lights[i].r, directional_lights[i].g, directional_lights[i].b));

					color->r += colorToAdd.r;
					color->g += colorToAdd.g;
					color->b += colorToAdd.b;
				}

			}

			for (std::vector<PointLight>::size_type i = 0; i < point_lights.size(); i++) {
				// TODO:
				// Generate light ray from the intersection point to the light position
				// point_lights[i].generateLightRay(intersection.differentialGeometry, &lightRay, &lightColor);
				// if this light ray is not blocked, do:
				//     *color += shading(intersection.differentialGeometry, brdf, lightRay, lightColor);

				point_lights[i].generateLightRay(intersection.differentialGeometry, &lightRay, &lightColor);

				// For now, we just ignore shadows and reflections and just apply our shading model
				// i.e. just call:
				Color colorToAdd = applyShadingModel(
						intersection.differentialGeometry,
						brdf, lightRay,
						Color(point_lights[i].r, point_lights[i].g, point_lights[i].b));

				color->r += colorToAdd.r;
				color->g += colorToAdd.g;
				color->b += colorToAdd.b;
			}

			// ***** Mirror reflection *****
			if (brdf.kr.greaterThanZero()) {
				// First, create our reflection ray...
				// r = d - 2(d . n)n

				// n
				Vector3 directional_normal_vector =
						Vector3::normalizeVector(Vector3(intersection.differentialGeometry.normal.x, intersection.differentialGeometry.normal.y, intersection.differentialGeometry.normal.z));

				Point intersectionMinusRaySource = intersection.differentialGeometry.position.subtractPoint(ray.position);

				// d (view vector) = intersection coordinate - source of ray
				// (we can't just use the intersection point, because our view is relative from the LAST HIT primitive)
				Vector3 view_vector = Vector3::normalizeVector(
						Vector3(intersectionMinusRaySource.x, intersectionMinusRaySource.y, intersectionMinusRaySource.z));


				float dDotN = view_vector.dotProduct(directional_normal_vector);
				Vector3 twoTimesdDotNTimesN = directional_normal_vector.scaleVector(dDotN * 2.0);
				Vector3 directional_reflective_vector_prenormalize = view_vector.subtractVector(twoTimesdDotNTimesN);
				// r
				Vector3 directional_reflective_vector = Vector3::normalizeVector(directional_reflective_vector_prenormalize);

				// NOTE: Not sure if this is right...
				// Offset our reflection ray's position a tiny bit in the direction of the normal
				Vector3 normalDirectionError = Vector3(intersection.differentialGeometry.normal.x, intersection.differentialGeometry.normal.y, intersection.differentialGeometry.normal.z).scaleVector(0.000001);
				Point offsetRayPosition = Point(intersection.differentialGeometry.position.x + normalDirectionError.x,
						intersection.differentialGeometry.position.y + normalDirectionError.y,
						intersection.differentialGeometry.position.z + normalDirectionError.z);

				Ray reflectionRay = Ray(offsetRayPosition, directional_reflective_vector, 0.001, FLT_MAX);

				Color tempColor;

				// Recursively call trace()
				trace(reflectionRay, depth + 1, &tempColor);

				color->r += brdf.kr.r * (tempColor.r / 255.0);
				color->g += brdf.kr.g * (tempColor.g / 255.0);
				color->b += brdf.kr.b * (tempColor.b / 255.0);

			}
		}
};

// (Declaration of RayTracer global variable)
RayTracer rayTracer;


//****************************************************
// applies Phong shading model to differentialGeometry.position
//****************************************************
Color applyShadingModel(DifferentialGeometry differentialGeometry, BRDFCoefficients brdf, Ray lightRay, Color lightColor) {

	// ***** BEGIN COMPUTATION OF PHONG SHADING MODEL ***** //
	// NOTE: Ambient term (ka) is appended outisde of this model

	float resultant_rgb_sum_of_pixel_r = 0;
	float resultant_rgb_sum_of_pixel_g = 0;
	float resultant_rgb_sum_of_pixel_b = 0;

	// Set viewer vector to -1 * incoming_ray's_vector
	Vector3 viewer_vector = Vector3::normalizeVector(Vector3(-1.0 * differentialGeometry.position.x, -1.0 * differentialGeometry.position.y, -1.0 * differentialGeometry.position.z));

	// **************************************
    // For directional light
	// **************************************
	if (lightRay.t_max == FLT_MAX) {

		// Direction of light ray computed in 'generateLightRay()'
		Vector3 prenormalized_directional_light_vector = lightRay.direction;

		// Change orientation of light vector to point inwards to sphere
		Vector3 directional_light_vector = Vector3::normalizeVector(prenormalized_directional_light_vector.scaleVector(-1));

		// NOTE: (x, y, z) is in world coordinates now, not relative to center of sphere
		// NOTE: we should defer this logic to Sphere/Triangle, as follows:
		Vector3 directional_normal_vector = Vector3(differentialGeometry.normal.x, differentialGeometry.normal.y, differentialGeometry.normal.z);

		float directional_diffuse_dot_product = fmax(directional_light_vector.dotProduct(directional_normal_vector), 0);
		float directional_diffuse_r = brdf.kd.r * lightColor.r * directional_diffuse_dot_product;
		float directional_diffuse_g = brdf.kd.g * lightColor.g * directional_diffuse_dot_product;
		float directional_diffuse_b = brdf.kd.b * lightColor.b * directional_diffuse_dot_product;

		// Calculate specular term
		Vector3 directional_reflective_vector = directional_normal_vector.scaleVector(directional_light_vector.dotProduct(directional_normal_vector) * 2).subtractVector(directional_light_vector);

		float directional_specular_dot_product_term = pow(fmax(directional_reflective_vector.dotProduct(viewer_vector), 0), brdf.sp);

		float directional_specular_r = brdf.ks.r * lightColor.r * directional_specular_dot_product_term;
		float directional_specular_g = brdf.ks.g * lightColor.g * directional_specular_dot_product_term;
		float directional_specular_b = brdf.ks.b * lightColor.b * directional_specular_dot_product_term;

		// Combine three contributions together
		resultant_rgb_sum_of_pixel_r += (directional_diffuse_r + directional_specular_r);
		resultant_rgb_sum_of_pixel_g += (directional_diffuse_g + directional_specular_g);
		resultant_rgb_sum_of_pixel_b += (directional_diffuse_b + directional_specular_b);
	} else {
		// **************************************
		// For point light
		// **************************************

		// Calculate diffuse term

		// Location of point light given by command line options (i.e. x, y, z)
		Vector3 normalized_point_light_location = lightRay.direction;

		Vector3 point_normal_vector = Vector3(differentialGeometry.normal.x, differentialGeometry.normal.y, differentialGeometry.normal.z);

		Vector3 prenormalized_point_light_vector = normalized_point_light_location.subtractVector(point_normal_vector).scaleVector(1);
		Vector3 point_light_vector = Vector3::normalizeVector(prenormalized_point_light_vector);

		float point_diffuse_dot_product = fmax(point_light_vector.dotProduct(point_normal_vector), 0);
		float point_diffuse_r = brdf.kd.r * lightColor.r * point_diffuse_dot_product;
		float point_diffuse_g = brdf.kd.g * lightColor.g * point_diffuse_dot_product;
		float point_diffuse_b = brdf.kd.b * lightColor.b * point_diffuse_dot_product;

		// Calculate specular term
		Vector3 point_reflective_vector = point_normal_vector.scaleVector(point_light_vector.dotProduct(point_normal_vector) * 2).subtractVector(point_light_vector);
		float point_specular_dot_product_term = pow(fmax(point_reflective_vector.dotProduct(viewer_vector), 0), brdf.sp);
		float point_specular_r = brdf.ks.r * lightColor.r * point_specular_dot_product_term;
		float point_specular_g = brdf.ks.g * lightColor.g * point_specular_dot_product_term;
		float point_specular_b = brdf.ks.b * lightColor.b * point_specular_dot_product_term;

		// Combine three contributions together
		resultant_rgb_sum_of_pixel_r += (point_diffuse_r + point_specular_r);
		resultant_rgb_sum_of_pixel_g += (point_diffuse_g + point_specular_g);
		resultant_rgb_sum_of_pixel_b += (point_diffuse_b + point_specular_b);
	}

	return Color(resultant_rgb_sum_of_pixel_r, resultant_rgb_sum_of_pixel_g, resultant_rgb_sum_of_pixel_b);
}


//****************************************************
// Debug printing functions
//****************************************************

static void printRay(Ray ray) {
	if (debug) {
		printf("Ray: (%f, %f, %f) + t(%f, %f, %f)\n", ray.position.x, ray.position.y, ray.position.z, ray.direction.x, ray.direction.y, ray.direction.z);
	}
}

static void printSample(Sample sample) {
	if (debug) {
		std::cout << "Sample: x = " << sample.x << "; y = " << sample.y << "\n";
	}
}

static void printVector(Vector3 vector) {
	if (debug) {
		std::cout << "Vector: x = " << vector.x << "; y = " << vector.y << "; z = " << vector.z << "\n";
	}
}

static void printColor(Color color) {
	if (debug) {
		printf("Color: (r, g, b) = (%f, %f, %f)\n", color.r, color.g, color.b);
	}
}

static void printPoint(Point point) {
	if (debug) {
		printf("Point: (x, y, z) = (%f, %f, %f)\n", point.x, point.y, point.z);
	}
}

Point eye;
Point imagePlaneTopLeft;
Point imagePlaneBottomLeft;
Point imagePlaneTopRight;
Point imagePlaneBottomRight;

void printGlobalVariables()
{
  if (debug)
  {
    std::cout << "\n***** BEGIN PRINTING GLOBAL VARIABLES *****\n";
    std::cout << "  " << "Film Width: " << film.width << "\n";
    std::cout << "  " << "Film Height: " << film.height << "\n\n";
    std::cout << "  Recursion Depth: " << recursionDepth << "\n\n";

    std::cout << "  Camera:\n";
    std::cout << "    Eye: ";
    printPoint(camera.eye);
    std::cout << "    Bottom Left Corner: ";
    printPoint(camera.imagePlaneBottomLeft);
    std::cout << "    Top Left Corner: ";
    printPoint(camera.imagePlaneTopLeft);
    std::cout << "    Bottom Right: ";
    printPoint(camera.imagePlaneBottomRight);
    std::cout << "    Top Right: ";
    printPoint(camera.imagePlaneTopRight);
    std::cout << "\n";

    std::cout << "Directional Lights:\n";
    if (directional_lights.size() == 0)
    {
      std::cout << " (none)\n";
    }
    for (std::vector<DirectionalLight>::size_type i = 0; i < directional_lights.size(); i++)
    {
      std::cout << "  " << "Light " << (i + 1) << "\n";
      std::cout << "     " << "x: " << directional_lights[i].x << " y: " << directional_lights[i].x << " z: " << directional_lights[i].x << "\n";
      std::cout << "     " << "r: " << directional_lights[i].r << " g: " << directional_lights[i].g << " b: " << directional_lights[i].b << "\n";
    }

    std::cout << "\nPoint Lights:\n";
    if (point_lights.size() == 0)
    {
      std::cout << " (none)\n";
    }
    for (std::vector<PointLight>::size_type i = 0; i < point_lights.size(); i++)
    {
      std::cout << "  " << "Light " << (i + 1) << "\n";
      std::cout << "     " << "x: " << point_lights[i].x << " y: " << point_lights[i].x << " z: " << point_lights[i].x << "\n";
      std::cout << "     " << "r: " << point_lights[i].r << " g: " << point_lights[i].g << " b: " << point_lights[i].b << "\n";
    }

    std::cout << "\n";

    std::cout << "Number of primitives: " << aggregatePrimitive.listOfPrimitives.size() << "\n\n";
    for (std::vector<GeometricPrimitive*>::size_type i = 0; i < aggregatePrimitive.listOfPrimitives.size(); i++) {
    	GeometricPrimitive* currentPrimitive = aggregatePrimitive.listOfPrimitives[i];
    	std::string shapeType = currentPrimitive->shape->shapeType();
    	cout << shapeType << "\n";

    	cout << currentPrimitive->shape->printShapeInformation();

    	cout << "  KA: ";
    	printColor(currentPrimitive->material->constantBRDF.ka);
    	cout << "  KD: ";
    	printColor(currentPrimitive->material->constantBRDF.kd);
    	cout << "  KR: ";
    	printColor(currentPrimitive->material->constantBRDF.kr);
    	cout << "  KS: ";
    	printColor(currentPrimitive->material->constantBRDF.ks);
    	cout << "  SP: " << currentPrimitive->material->constantBRDF.sp << "\n\n";
    }

    std::cout << "***** FINISH PRINTING GLOBAL VARIABLES *****\n\n";
  }
}

// Prints contents of samples and buckets for debug purposes
void printSamples() {
	if (debug) {
		for (vector<Sample>::size_type i = 0; i < samples.size(); i++) {
			printSample(samples[i]);
		}
	}
}




//****************************************************
// Parsing of command line options, with options:
// (1) -dimensions width height
//     adds viewport width and height attributes to Viewport global variable
// (2) -depth n
//     sets recursion depth
// (3) -dl x y z r g b
//     (directional lights)
// (4) -pl x y z r g b
//     (point lights)
//
// NOTE: also performs proper initialization of Film and Camera global variables
//****************************************************
void parseCommandLineOptions(int argc, char *argv[])
{
  string flag;

  int i = 1;
  while (i <= argc - 1) {
    flag = argv[i];

    if (flag == "-dimensions")
	{
	  // Check that -dimensions has enough option parameters
	  if ((i + 2) > (argc - 1))
	  {
		std::cout << "Invalid number of parameters for -dimensions.";
		exit(1);
	  }

	  int widthOfFilm = stoi(argv[i+1]);
	  int heightOfFilm = stoi(argv[i+2]);

//	  if (widthOfFilm < 1000 || heightOfFilm < 500 || widthOfFilm > 3000 || heightOfFilm > 3000) {
//		  std::cout << "Dimensions of output file must be at least 1000x500 and no more than 3000x3000.";
//		  exit(1);
//	  }

	  film = Film(widthOfFilm, heightOfFilm);

	  camera = Camera(widthOfFilm, heightOfFilm, 0.0, 0.0, 0.0,
			  -1.0, -1.0, -3.0,
			  1.0, -1.0, -3.0,
			  1.0, 1.0, -3.0,
			  -1.0, 1.0, -3.0);

	  i += 2;
	}
    else if (flag == "-depth")
	{
	  // Check that -depth has enough option parameters
	  if ((i + 1) > (argc - 1))
	  {
		std::cout << "Invalid number of parameters for -depth.";
		exit(1);
	  }
	  recursionDepth = stoi(argv[i+1]);
	  i += 1;
	}
    else if (flag == "-dl")
    {
      // Check that -dl has enough option parameters
      if ((i + 6) > (argc - 1))
      {
        std::cout << "Invalid number of parameters for -dl.";
        exit(1);
      }

      // Add directional lights to our directional lights list
      directional_lights.push_back( DirectionalLight( stof(argv[i+1]), stof(argv[i+2]), stof(argv[i+3]), stof(argv[i+4]), stof(argv[i+5]), stof(argv[i+6]) ) );
      i += 6;
    }
    else if (flag == "-pl")
    {
      // Check that -pl has enough option parameters
      if ((i + 6) > (argc - 1))
      {
        std::cout << "Invalid number of parameters for -pl.";
        exit(1);
      }

      point_lights.push_back( PointLight( stof(argv[i+1]), stof(argv[i+2]), stof(argv[i+3]), stof(argv[i+4]), stof(argv[i+5]), stof(argv[i+6]) ) );
      i += 6;
    }
    else
    {
      std::cout << "Extra parameters in command line options; terminating program.";
      exit(1);
    }

    // Advance to next flag, if one exists
    i++;
  }
}



//****************************************************
// Parsing scene file from command line
//****************************************************

void parseSceneFile(string filename) {
	ifstream file(filename);
	string str;

	// The identifier that we're currently parsing
	string currentlyParsing;

	// current word that we're parsing on a line
	string currentWord;

	// Index of a word on each specific line
	int i = 0;

	// Indicates whether the current line being read is valid
	bool validLine = true;

	// ***** Variables for object creation *****//
	// Camera
	float ex, ey, ez, llx, lly, llz, lrx, lry, lrz, ulx, uly, ulz, urx, ury, urz;
	// Most recently seen material
	float kar, kag, kab, kdr, kdg, kdb, ksr, ksg, ksb, ksp, krr, krg, krb;


	while (getline(file, str)) {
		// str represents the current line of the file

		validLine = true;
		i = 0;
		istringstream iss(str);
		while (iss >> currentWord) {

			// ********** Figure out what the first word of each line is ********** //
			if ((i == 0) && (currentWord == "cam")) {
				currentlyParsing = currentWord;
			} else if ((i == 0) && (currentWord == "ltd")) {
				currentlyParsing = currentWord;
			} else if ((i == 0) && (currentWord == "ltp")) {
				currentlyParsing = currentWord;
			} else if ((i == 0) && (currentWord == "lta")) {
				currentlyParsing = currentWord;
			} else if ((i == 0) && (currentWord == "mat")) {
				currentlyParsing = currentWord;
			} else if ((i == 0) && (currentWord == "sph")) {
				currentlyParsing = currentWord;
			} else if ((i == 0) && (currentWord == "tri")) {
				currentlyParsing = currentWord;


			// TODO: .obj, Transformation, reset transformation identifier

			// We've found an unspecified identifier as the first word on our line
			} else if (i == 0) {
				currentlyParsing = currentWord;
				validLine = false;
			}

			// If the current line is not valid, then just keep skipping every word in the line
			if (!validLine) {
				// Since currentlyParsing is a pointer to currentWord, currentlyParsing changes whenever currentWord
				// gets updated by iss, so must advance i to make sure currentlyParsing
				i++;
				continue;
			}







			// ********** After we've figured out the first word in each line, parse the rest of the line ********** //
			// If we've hit here, then we're NOT on the first word of the line anymore
			if (currentlyParsing == "cam") {
				if (i == 0) { }
				else if (i == 1) { ex = stof(currentWord); }
				else if (i == 2) { ey = stof(currentWord); }
				else if (i == 3) { ez = stof(currentWord); }
				else if (i == 4) { llx = stof(currentWord); }
				else if (i == 5) { lly = stof(currentWord); }
				else if (i == 6) { llz = stof(currentWord); }
				else if (i == 7) { lrx = stof(currentWord); }
				else if (i == 8) { lry = stof(currentWord); }
				else if (i == 9) { lrz = stof(currentWord); }
				else if (i == 10) { ulx = stof(currentWord); }
				else if (i == 11) { uly = stof(currentWord); }
				else if (i == 12) { ulz = stof(currentWord); }
				else if (i == 13) { urx = stof(currentWord); }
				else if (i == 14) { ury = stof(currentWord); }
				else if (i == 15) { urz = stof(currentWord); }
				else { cerr << "Extra parameters for " << currentlyParsing << ". Ignoring them.\n"; }

			} else if (currentlyParsing == "ltd") {
				float dx, dy, dz, r, g, b;
				if (i == 0) { }
				else if (i == 1) { dx = stof(currentWord); }
				else if (i == 2) { dy = stof(currentWord); }
				else if (i == 3) { dz = stof(currentWord); }
				else if (i == 4) { r = stof(currentWord); }
				else if (i == 5) { g = stof(currentWord); }
				else if (i == 6) { b = stof(currentWord); }
				else if (i > 6) {
					cerr << "Extra parameters for " << currentlyParsing << ". Ignoring them.\n";
				}
				if (i == 6) {
					// Add directional light to global list
					directional_lights.push_back(DirectionalLight(dx, dy, dz, r, g, b));
				}

			} else if (currentlyParsing == "ltp") {
				float px, py, pz, r, g, b, falloff;
				if (i == 0) { }
				else if (i == 1) { px = stof(currentWord); }
				else if (i == 2) { py = stof(currentWord); }
				else if (i == 3) { pz = stof(currentWord); }
				else if (i == 4) { r = stof(currentWord); }
				else if (i == 5) { g = stof(currentWord); }
				else if (i == 6) { b = stof(currentWord); }
				else if (i == 7) { falloff = stof(currentWord); }
				else if (i > 7) {
					cerr << "Extra parameters for " << currentlyParsing << ". Ignoring them.\n";
				}
				if (i == 6) {
					// Add point light to global list
					point_lights.push_back(PointLight(px, py, pz, r, g, b, falloff));
				}

			} else if (currentlyParsing == "mat") {
				if (i == 0) { }
				else if (i == 1) { kar = stof(currentWord); }
				else if (i == 2) { kag = stof(currentWord); }
				else if (i == 3) { kab = stof(currentWord); }
				else if (i == 4) { kdr = stof(currentWord); }
				else if (i == 5) { kdg = stof(currentWord); }
				else if (i == 6) { kdb = stof(currentWord); }
				else if (i == 7) { ksr = stof(currentWord); }
				else if (i == 8) { ksg = stof(currentWord); }
				else if (i == 9) { ksb = stof(currentWord); }
				else if (i == 10) { ksp = stof(currentWord); }
				else if (i == 11) { krr = stof(currentWord); }
				else if (i == 12) { krg = stof(currentWord); }
				else if (i == 13) { krb = stof(currentWord); }
				else { cerr << "Extra parameters for " << currentlyParsing << ". Ignoring them. i is : " << i << "\n"; }

			} else if (currentlyParsing == "sph") {
				float cx, cy, cz, r;
				if (i == 0) { }
				else if (i == 1) { cx = stof(currentWord); }
				else if (i == 2) { cy = stof(currentWord); }
				else if (i == 3) { cz = stof(currentWord); }
				else if (i == 4) { r = stof(currentWord); }
				else if (i > 4) {
					cerr << "Extra parameters for " << currentlyParsing << ". Ignoring them. i is : " << i << "\n";
				}
				if (i == 4) {
					// Initialize our sphere, with the last seen material
					GeometricPrimitive* primitiveToAdd = new GeometricPrimitive();
					Sphere* sphereToAdd = new Sphere(cx, cy, cz, r);
					BRDFCoefficients *brdfToAdd = new BRDFCoefficients();
					Color* kaToAdd = new Color(kar, kag, kab);
					Color* kdToAdd = new Color(kdr, kdg, kdb);
					Color* ksToAdd = new Color(ksr, ksg, ksb);
					Color* krToAdd = new Color(krr, krg, krb);
					brdfToAdd->ka = *kaToAdd;
					brdfToAdd->kd = *kdToAdd;
					brdfToAdd->ks = *ksToAdd;
					brdfToAdd->kr = *krToAdd;
					brdfToAdd->sp = ksp;
					Material* materialToAdd = new Material();
					materialToAdd->constantBRDF = *brdfToAdd;
					primitiveToAdd->material = materialToAdd;
					primitiveToAdd->shape = sphereToAdd;
					aggregatePrimitive.addPrimitive(primitiveToAdd);
				}
			}

			i++;
		}



		if (!validLine) {
			cerr << "Unsupported feature: " << currentlyParsing << ". Ignoring line.\n";
		}


	}

	// ***** Initialize Camera global variable ***** //
	camera = Camera(1000, 1000, ex, ey, ez, llx, lly, llz, lrx, lry, lrz, urx, ury, urz, ulx, uly, ulz);
}






//****************************************************
// Main rendering loop
//
// Loops through samples, and does the following per sample:
// (1) generates a ray from the eye through the sample
// (2) traces this ray with the ray tracer
// (3) commits the color returns by the ray tracer to the film
//****************************************************
void render() {
	// Loop through all of the samples...
	for (vector<Sample>::size_type i = 0; i < samples.size(); i++) {

		// For each sample, generate a ray from the eye to the sample location
		Ray currentRay;
		Color currentSampleColor;

		// Given the sample in Film-coordinates, tell the camera to generate a viewing ray in IMAGE PLANE [-1, 1] coordinates
		camera.generateRay(samples[i], &currentRay);

		// Call the trace method to try to populate currentSampleColor for the currentSample
		rayTracer.trace(currentRay, 0, &currentSampleColor);

		// Commit the currentSampleColor for the currentSample onto our Film

		film.commitColor(samples[i], currentSampleColor);

	}

}


//****************************************************
// Populates a list of samples based on the film height and width
//****************************************************
void initializeSampler() {
	float x, y;
	// Generates samples in the FILM's coordinates
	for (y = 0; y < film.height; y++) {
		for (x = 0; x < film.width; x++) {
			samples.push_back(Sample(x, y));
		}
	}

}


//****************************************************
// Initializes primitives for our scene
//****************************************************
void initializePrimitives() {
	// Must use 'new', as need to store pointers to variables that will live outside of the scope of this function
//	Sphere *sphere1 = new Sphere(0, 0, -20, 3);
//	Material *material1 = new Material();
//	BRDFCoefficients *brdf = new BRDFCoefficients();
//
//	// ka
//	Color *color1 = new Color(25.5, 25.5, 25.5);
//
//	// kd
//	Color *color2 = new Color(255, 0, 255);
//
//	// ks
//	Color *color3 = new Color(255, 255, 255);
//
//	brdf->ka = *color1;
//	brdf->kd = *color2;
//	brdf->ks = *color3;
//	brdf->sp = 50;
//	material1->constantBRDF = *brdf;
//
//	GeometricPrimitive *primitive1 = new GeometricPrimitive();
//	primitive1->shape = sphere1;
//	primitive1->material = material1;
//	aggregatePrimitive.addPrimitive(primitive1);
//
//	///////////////////////
//
//	Material *material2 = new Material();
//	BRDFCoefficients *brdf2 = new BRDFCoefficients();
//
//	// ka
//	Color *color4 = new Color(25.5, 25.5, 25.5);
//
//	// kd
//	Color *color5 = new Color(255, 255, 0);
//
//	// ks
//	Color *color6 = new Color(255, 255, 255);
//	brdf2->ka = *color4;
//	brdf2->kd = *color5;
//	brdf2->ks = *color6;
//	brdf2->sp = 50;
//
//
//	Sphere *sphere2 = new Sphere(-2, 2, -15, 1);
//
//	material2->constantBRDF = *brdf2;
//
//	GeometricPrimitive *primitive2 = new GeometricPrimitive();
//
//	primitive2->shape = sphere2;
//	primitive2->material = material2;
//
//	aggregatePrimitive.addPrimitive(primitive2);
//
//	///////////////////////
//
//	Material *material3 = new Material();
//	BRDFCoefficients *brdf3 = new BRDFCoefficients();
//
//	// ka
//	Color *color7 = new Color(25.5, 25.5, 25.5);
//
//	// kd
//	Color *color8 = new Color(0, 255, 255);
//
//	// ks
//	Color *color9 = new Color(255, 255, 255);
//	brdf3->ka = *color7;
//	brdf3->kd = *color8;
//	brdf3->ks = *color9;
//	brdf3->sp = 50;
//
//	Sphere *sphere3 = new Sphere(-2, -2, -15, 1);
//
//	material3->constantBRDF = *brdf3;
//
//	GeometricPrimitive *primitive3 = new GeometricPrimitive();
//
//	primitive3->shape = sphere3;
//	primitive3->material = material3;
//
//	aggregatePrimitive.addPrimitive(primitive3);

	//	///////////////////////




















	Sphere *sphere1 = new Sphere(0, 0, -17, 2);
	Material *material1 = new Material();
	BRDFCoefficients *brdf = new BRDFCoefficients();

	// ka
	Color *color1 = new Color(25.5, 25.5, 25.5);

	// kd
	Color *color2 = new Color(255, 0, 0);

	// ks
	Color *color3 = new Color(255, 255, 255);

	// kr
	Color *color50 = new Color(229.5, 229.5, 229.5);

	brdf->ka = *color1;
	brdf->kd = *color2;
	brdf->ks = *color3;
	brdf->kr = *color50;
	brdf->sp = 50;
	material1->constantBRDF = *brdf;

	GeometricPrimitive *primitive1 = new GeometricPrimitive();
	primitive1->shape = sphere1;
	primitive1->material = material1;
	aggregatePrimitive.addPrimitive(primitive1);


	//////////////////////

	Material *material2 = new Material();
	BRDFCoefficients *brdf2 = new BRDFCoefficients();

	// ka
	Color *color4 = new Color(25.5, 25.5, 25.5);

	// kd
	Color *color5 = new Color(0, 255, 0);

	// ks
	Color *color6 = new Color(255, 255, 255);

	// kr
	Color *color51 = new Color(229.5, 229.5, 229.5);
	brdf2->ka = *color4;
	brdf2->kd = *color5;
	brdf2->ks = *color6;
	brdf2->kr = *color51;
	brdf2->sp = 50;


	Sphere *sphere2 = new Sphere(0, 4, -17, 1.5);

	material2->constantBRDF = *brdf2;

	GeometricPrimitive *primitive2 = new GeometricPrimitive();

	primitive2->shape = sphere2;
	primitive2->material = material2;

	aggregatePrimitive.addPrimitive(primitive2);

	///////////////////////

	Material *material3 = new Material();
	BRDFCoefficients *brdf3 = new BRDFCoefficients();

	// ka
	Color *color7 = new Color(25.5, 25.5, 25.5);

	// kd
	Color *color8 = new Color(0, 0, 255);

	// ks
	Color *color9 = new Color(255, 255, 255);

	// kr
	brdf3->ka = *color7;
	brdf3->kd = *color8;
	brdf3->ks = *color9;
	brdf3->kr = *color51;
	brdf3->sp = 50;

	Sphere *sphere3 = new Sphere(0, -4, -17, 1.5);

	material3->constantBRDF = *brdf3;

	GeometricPrimitive *primitive3 = new GeometricPrimitive();

	primitive3->shape = sphere3;
	primitive3->material = material3;

	aggregatePrimitive.addPrimitive(primitive3);


	Material *material4 = new Material();
	BRDFCoefficients *brdf4 = new BRDFCoefficients();

	// ka
	Color *color10 = new Color(25.5, 25.5, 25.5);

	// kd
	Color *color11 = new Color(255, 255, 0);

	// ks
	Color *color12 = new Color(255, 255, 255);
	brdf4->ka = *color10;
	brdf4->kd = *color11;
	brdf4->ks = *color12;
	brdf4->kr = *color51;
	brdf4->sp = 50;


	Sphere *sphere4 = new Sphere(4, 0, -17, 1.5);

	material4->constantBRDF = *brdf4;

	GeometricPrimitive *primitive4 = new GeometricPrimitive();

	primitive4->shape = sphere4;
	primitive4->material = material4;

	aggregatePrimitive.addPrimitive(primitive4);

	///////////////////////

	Material *material5 = new Material();
	BRDFCoefficients *brdf5 = new BRDFCoefficients();

	// ka
	Color *color13 = new Color(25.5, 25.5, 25.5);

	// kd
	Color *color14 = new Color(0, 255, 255);

	// ks
	Color *color15 = new Color(255, 255, 255);
	brdf5->ka = *color13;
	brdf5->kd = *color14;
	brdf5->ks = *color15;
	brdf5->kr = *color51;
	brdf5->sp = 50;

	Sphere *sphere5 = new Sphere(-4, 0, -17, 1.5);

	material5->constantBRDF = *brdf5;

	GeometricPrimitive *primitive5 = new GeometricPrimitive();

	primitive5->shape = sphere5;
	primitive5->material = material5;

	aggregatePrimitive.addPrimitive(primitive5);

}


//****************************************************
// Main function
//****************************************************
int main(int argc, char *argv[]) {
  // Turns debug mode ON or OFF
  debug = true;

  // Parse command line options
  film = Film(1000, 1000);
  recursionDepth = 5;
  parseSceneFile(argv[1]);

  cout << "Just finished parsing scene file.\n";
  printGlobalVariables();

  // Initializes list of buckets; Buckets have a list of samples
  initializeSampler();
//  initializePrimitives();
  render();

  film.writeImage("ray_tracer_output.png");

  return 0;
};

